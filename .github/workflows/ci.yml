name: CI/CD Pipeline

# Ce workflow dÃ©finit un pipeline CI/CD complet pour l'application Java Spring Boot
# Il s'exÃ©cute sur les push et PR vers main/master

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

permissions:
  contents: read
  packages: write

env:
  IMAGE_TAG_PATIENT: ghcr.io/${{ github.repository_owner }}/patient-service:${{ github.sha }}
  IMAGE_TAG_DOCTOR: ghcr.io/${{ github.repository_owner }}/doctor-service:${{ github.sha }}
  REGISTRY: ghcr.io
  STAGING_NAMESPACE: medinsight-staging
  PROD_NAMESPACE: medinsight-prod
  APP_PORT_PATIENT: 8050
  APP_PORT_DOCTOR: 8082
  NODE_PORT_STAGING_PATIENT: "30080"
  NODE_PORT_STAGING_DOCTOR: "30081"
  NODE_PORT_PROD_PATIENT: "30082"
  NODE_PORT_PROD_DOCTOR: "30083"

jobs:
  # Job 1: PrÃ©-vÃ©rification - DÃ©tection de secrets
  precheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gitleaks - secrets detection
        run: |
          docker run --rm -v $(pwd):/src zricethezav/gitleaks:latest detect \
            --source /src \
            --no-git \
            --report-format json \
            --report-path /src/gitleaks.json \
            --exit-code 0 || true
          [ -s gitleaks.json ] || echo "[]" > gitleaks.json
        continue-on-error: true

      - name: Display Gitleaks report
        run: |
          if [ -f gitleaks.json ]; then
            cat gitleaks.json
          else
            echo "No gitleaks report generated"
          fi
        continue-on-error: true

      - name: Upload Gitleaks report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks.json
        if: always()

  # Job 2: Scan - Analyse de sÃ©curitÃ© et qualitÃ© du code
  scan:
    runs-on: ubuntu-latest
    needs: precheck
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube (SAST)
        run: |
          docker run --rm -v $(pwd):/usr/src \
            -e SONAR_TOKEN=${{ secrets.SONAR_TOKEN }} \
            -e SONAR_HOST_URL=${{ secrets.SONAR_HOST_URL }} \
            -e SONAR_ORGANIZATION=${{ secrets.SONAR_ORGANIZATION }} \
            -e SONAR_PROJECT_KEY=${{ secrets.SONAR_PROJECT_KEY }} \
            sonarsource/sonar-scanner-cli:latest \
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }} \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.login=${{ secrets.SONAR_TOKEN }} \
            -Dsonar.sources=services \
            -Dsonar.java.source=17 \
            -Dsonar.java.target=17 \
            -Dsonar.exclusions=**/test/**
        continue-on-error: true

      - name: Snyk (SCA)
        run: |
          touch snyk-report.json
          docker run --rm -v $(pwd):/src \
            -e SNYK_TOKEN=${{ secrets.SNYK_TOKEN }} \
            snyk/snyk:maven-3-jdk-17 sh -c "cd /src && snyk auth \$SNYK_TOKEN && snyk test --all-projects --json-file=/src/snyk-report.json" || true
        continue-on-error: true

      - name: Upload Snyk report
        uses: actions/upload-artifact@v4
        with:
          name: snyk-report
          path: snyk-report.json
        if: always()

  # Job 3: Build - Construction de l'image Docker
  build:
    runs-on: ubuntu-latest
    needs: scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build patient-service Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/patient-service
          tags: ${{ env.IMAGE_TAG_PATIENT }}, patient-local:latest
          outputs: type=docker,dest=patient-docker-image.tar

      - name: Build doctor-service Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/doctor-service
          tags: ${{ env.IMAGE_TAG_DOCTOR }}, doctor-local:latest
          outputs: type=docker,dest=doctor-docker-image.tar

      - name: Upload patient Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: patient-docker-image
          path: patient-docker-image.tar

      - name: Upload doctor Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: doctor-docker-image
          path: doctor-docker-image.tar

  # Job 4: Image-scan - Scan de vulnÃ©rabilitÃ©s de l'image Docker
  image-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download patient Docker image
        uses: actions/download-artifact@v4
        with:
          name: patient-docker-image
          path: .

      - name: Download doctor Docker image
        uses: actions/download-artifact@v4
        with:
          name: doctor-docker-image
          path: .

      - name: Load patient Docker image
        run: docker load < patient-docker-image.tar

      - name: Load doctor Docker image
        run: docker load < doctor-docker-image.tar

      - name: Trivy scan patient-service
        run: |
          docker run --rm -v $(pwd):/reports aquasec/trivy:latest image patient-local:latest --format json --output /reports/trivy-patient-report.json --severity HIGH,CRITICAL || true

      - name: Trivy scan doctor-service
        run: |
          docker run --rm -v $(pwd):/reports aquasec/trivy:latest image doctor-local:latest --format json --output /reports/trivy-doctor-report.json --severity HIGH,CRITICAL || true

      - name: Check Trivy results for patient-service
        run: |
          if [ -f trivy-patient-report.json ]; then
            cat trivy-patient-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-patient-report.json || echo 0)
            echo "CRITICAL vulns in patient-service: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "âŒ CRITICAL vulnerabilities detected in patient-service. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report for patient-service"
          fi

      - name: Check Trivy results for doctor-service
        run: |
          if [ -f trivy-doctor-report.json ]; then
            cat trivy-doctor-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-doctor-report.json || echo 0)
            echo "CRITICAL vulns in doctor-service: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "âŒ CRITICAL vulnerabilities detected in doctor-service. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report for doctor-service"
          fi

      - name: Upload Trivy patient report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-patient-report
          path: trivy-patient-report.json
        if: always()

      - name: Upload Trivy doctor report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-doctor-report
          path: trivy-doctor-report.json
        if: always()

  # Job 5: Push - Push de l'image vers le registre
  push:
    runs-on: ubuntu-latest
    needs: image-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    permissions:
      packages: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download patient Docker image
        uses: actions/download-artifact@v4
        with:
          name: patient-docker-image
          path: .

      - name: Download doctor Docker image
        uses: actions/download-artifact@v4
        with:
          name: doctor-docker-image
          path: .

      - name: Load patient Docker image
        run: docker load < patient-docker-image.tar

      - name: Load doctor Docker image
        run: docker load < doctor-docker-image.tar

      - name: Tag patient image
        run: docker tag patient-local:latest ${{ env.IMAGE_TAG_PATIENT }}

      - name: Tag doctor image
        run: docker tag doctor-local:latest ${{ env.IMAGE_TAG_DOCTOR }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Push patient image
        run: docker push ${{ env.IMAGE_TAG_PATIENT }}

      - name: Push doctor image
        run: docker push ${{ env.IMAGE_TAG_DOCTOR }}

  # Job 6: Deploy to staging - DÃ©ploiement en environnement de staging
  deploy-to-staging:
    runs-on: ubuntu-latest
    needs: push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Configure kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
          kubectl cluster-info
          kubectl get nodes

      - name: Create staging namespace if not exists
        run: |
          kubectl create namespace ${{ env.STAGING_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to staging
        env:
          NAMESPACE: ${{ env.STAGING_NAMESPACE }}
          IMAGE_TAG_PATIENT: ${{ env.IMAGE_TAG_PATIENT }}
          IMAGE_TAG_DOCTOR: ${{ env.IMAGE_TAG_DOCTOR }}
          APP_PORT_PATIENT: ${{ env.APP_PORT_PATIENT }}
          APP_PORT_DOCTOR: ${{ env.APP_PORT_DOCTOR }}
          NODE_PORT_PATIENT: ${{ env.NODE_PORT_STAGING_PATIENT }}
          NODE_PORT_DOCTOR: ${{ env.NODE_PORT_STAGING_DOCTOR }}
        run: |
          echo "ðŸš€ Deploy patient-service"
          envsubst < k8s/patient-deployment.yaml | kubectl apply -n $NAMESPACE -f -
          envsubst < k8s/patient-service.yaml | kubectl apply -n $NAMESPACE -f -
          echo "ðŸš€ Deploy doctor-service"
          envsubst < k8s/doctor-deployment.yaml | kubectl apply -n $NAMESPACE -f -
          envsubst < k8s/doctor-service.yaml | kubectl apply -n $NAMESPACE -f -
          echo "â³ Waiting for rollout..."
          kubectl rollout status deployment/patient-service -n $NAMESPACE --timeout=5m
          kubectl rollout status deployment/doctor-service -n $NAMESPACE --timeout=5m

  # Job 7: Security-scan - Scan de sÃ©curitÃ© dynamique avec OWASP ZAP
  security-scan:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl for port-forward
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Configure kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config

      - name: Port forward and run OWASP ZAP scan
        run: |
          echo "ðŸ” Starting port-forward..."
          kubectl port-forward -n ${{ env.STAGING_NAMESPACE }} svc/patient-service 8080:${{ env.APP_PORT_PATIENT }} &
          FORWARD_PID=$!
          
          sleep 5
          
          echo "ðŸ“¦ Pulling ZAP image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          echo "ðŸš€ Starting ZAP scan..."
          docker run --rm \
            --network host \
            -v $(pwd):/zap/wrk/:rw \
            ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "http://localhost:8080" \
            -m 10 \
            -r zap_report.html \
            -J zap_report.json || true
          
          kill $FORWARD_PID || true

      - name: Upload ZAP reports
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: zap_report.*
        if: always()

  # Job 8: Promote to prod - Promotion en production (Manual approval required)
  promote-to-prod:
    runs-on: ubuntu-latest
    needs: security-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Configure kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config

      - name: Create prod namespace if not exists
        run: |
          kubectl create namespace ${{ env.PROD_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to production
        env:
          NAMESPACE: ${{ env.PROD_NAMESPACE }}
          IMAGE_TAG_PATIENT: ${{ env.IMAGE_TAG_PATIENT }}
          IMAGE_TAG_DOCTOR: ${{ env.IMAGE_TAG_DOCTOR }}
          APP_PORT_PATIENT: ${{ env.APP_PORT_PATIENT }}
          APP_PORT_DOCTOR: ${{ env.APP_PORT_DOCTOR }}
          NODE_PORT_PATIENT: ${{ env.NODE_PORT_PROD_PATIENT }}
          NODE_PORT_DOCTOR: ${{ env.NODE_PORT_PROD_DOCTOR }}
        run: |
          echo "ðŸš€ Deploy patient-service to production"
          envsubst < k8s/patient-deployment.yaml | kubectl apply -n $NAMESPACE -f -
          envsubst < k8s/patient-service.yaml | kubectl apply -n $NAMESPACE -f -
          echo "ðŸš€ Deploy doctor-service to production"
          envsubst < k8s/doctor-deployment.yaml | kubectl apply -n $NAMESPACE -f -
          envsubst < k8s/doctor-service.yaml | kubectl apply -n $NAMESPACE -f -
          echo "â³ Waiting for rollout..."
          kubectl rollout status deployment/patient-service -n $NAMESPACE --timeout=5m
          kubectl rollout status deployment/doctor-service -n $NAMESPACE --timeout=5m

      - name: Create production info artifact
        run: |
          cat > service_info.env <<EOF
          PATIENT_SERVICE_URL=http://$(kubectl get svc patient-service -n ${{ env.PROD_NAMESPACE }} -o jsonpath='{.spec.clusterIP}'):${{ env.APP_PORT_PATIENT }}
          DOCTOR_SERVICE_URL=http://$(kubectl get svc doctor-service -n ${{ env.PROD_NAMESPACE }} -o jsonpath='{.spec.clusterIP}'):${{ env.APP_PORT_DOCTOR }}
          DEPLOYMENT_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          DEPLOYMENT_COMMIT=${{ github.sha }}
          EOF

      - name: Upload service info
        uses: actions/upload-artifact@v4
        with:
          name: prod-service-info
          path: service_info.env