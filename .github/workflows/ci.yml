name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_TAG: ghcr.io/rania236/medinsight:${{ github.sha }}
  REGISTRY: ghcr.io
  STAGING_NAMESPACE: dev
  PROD_NAMESPACE: prod
  APP_PORT: 5000
  NODE_PORT_STAGING: "30080"
  NODE_PORT_PROD: "30081"
  MINIKUBE_IP: "192.168.58.2"
  SONAR_USER_HOME: "${{ github.workspace }}/.sonar"
  GIT_DEPTH: 0

jobs:
  precheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gitleaks - secrets detection
        uses: docker://zricethezav/gitleaks:latest
        with:
          args: detect --source . --report-format json --report-path gitleaks.json || exit_code=$?
        continue-on-error: true

      - name: Display Gitleaks report
        run: |
          if [ -f gitleaks.json ]; then
            cat gitleaks.json
          else
            echo "No gitleaks report generated"
          fi
        continue-on-error: true

      - name: Upload Gitleaks report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks.json
        if: always()

  scan:
    runs-on: ubuntu-latest
    needs: precheck
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube (SAST)
        uses: docker://sonarsource/sonar-scanner-cli:latest
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        with:
          args: |
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}
            -Dsonar.login=${{ secrets.SONAR_TOKEN }}

      - name: Snyk (SCA)
        uses: docker://node:18
        with:
          args: |
            npm install -g snyk
            snyk auth ${{ secrets.SNYK_TOKEN }}
            snyk test --json > snyk-report.json
        continue-on-error: true

      - name: Upload Snyk report
        uses: actions/upload-artifact@v4
        with:
          name: snyk-report
          path: snyk-report.json
        if: always()

  build:
    runs-on: ubuntu-latest
    needs: scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_TAG }}, local-image:latest
          outputs: type=docker,dest=docker-image.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar

  image-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Trivy scan
        uses: docker://aquasec/trivy:latest
        with:
          args: image --input docker-image.tar --format json --output trivy-report.json --severity HIGH,CRITICAL
        continue-on-error: true

      - name: Check Trivy results
        run: |
          if [ -f trivy-report.json ]; then
            cat trivy-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-report.json || echo 0)
            echo "CRITICAL vulns: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "‚ùå CRITICAL vulnerabilities detected by Trivy. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report generated"
          fi

      - name: Upload Trivy report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-report.json
        if: always()

  push:
    runs-on: ubuntu-latest
    needs: image-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Load Docker image
        run: docker load < docker-image.tar

      - name: Tag image
        run: docker tag local-image:latest ${{ env.IMAGE_TAG }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push image
        run: docker push ${{ env.IMAGE_TAG }}

  deploy-to-staging:
    runs-on: ubuntu-latest
    needs: push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        uses: docker://bitnami/kubectl:latest
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
          TARGET_NAMESPACE: ${{ env.STAGING_NAMESPACE }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          NODE_PORT: ${{ env.NODE_PORT_STAGING }}
        with:
          args: |
            mkdir -p ~/.kube
            echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
            CONTEXT=$(kubectl config get-contexts -o name | head -n1)
            kubectl config use-context "$CONTEXT"
            envsubst < k8s/deployment.yaml | kubectl apply -n "$TARGET_NAMESPACE" -f - --validate=false
            envsubst < k8s/service.yaml | kubectl apply -n "$TARGET_NAMESPACE" -f - --validate=false
            kubectl rollout status deployment/myapp -n "$TARGET_NAMESPACE"

  security-scan:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: OWASP ZAP scan
        run: |
          echo "üîç Testing target availability..."
          curl -s --head --connect-timeout 30 "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" || echo "Target might be starting..."
          
          echo "üì¶ Pulling ZAP image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          echo "üöÄ Starting ZAP scan..."
          docker run --rm \
            -v $(pwd):/zap/wrk/:rw \
            -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" \
            -m 10 \
            -g gen.conf \
            -r zap_report.html \
            -J zap_report.json \
            -w zap_report.md

      - name: Upload ZAP reports
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: zap_report.*
        if: always()

  promote-to-prod:
    runs-on: ubuntu-latest
    needs: security-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Promote to production
        uses: docker://bitnami/kubectl:latest
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
          TARGET_NAMESPACE: ${{ env.PROD_NAMESPACE }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          NODE_PORT: ${{ env.NODE_PORT_PROD }}
        with:
          args: |
            mkdir -p ~/.kube
            echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
            CONTEXT=$(kubectl config get-contexts -o name | head -n1)
            kubectl config use-context "$CONTEXT"
            envsubst < k8s/deployment.yaml | kubectl apply -n "$TARGET_NAMESPACE" -f - --validate=false
            envsubst < k8s/service.yaml | kubectl apply -n "$TARGET_NAMESPACE" -f - --validate=false
            kubectl rollout status deployment/myapp -n "$TARGET_NAMESPACE"

      - name: Create service info artifact
        run: |
          echo "APP_URL=http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_PROD }}" > service_info.env

      - name: Upload service info
        uses: actions/upload-artifact@v4
        with:
          name: service-info
          path: service_info.env