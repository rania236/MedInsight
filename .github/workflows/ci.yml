name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  IMAGE_TAG: ghcr.io/rania236/medinsight:${{ github.sha }}
  REGISTRY: ghcr.io
  STAGING_NAMESPACE: dev
  PROD_NAMESPACE: prod
  APP_PORT: 8050
  NODE_PORT_STAGING: "30080"
  NODE_PORT_PROD: "30081"
  MINIKUBE_IP: "192.168.58.2"
  SONAR_USER_HOME: "${{ github.workspace }}/.sonar"
  GIT_DEPTH: 0

jobs:
  precheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Gitleaks - secrets detection
        run: |
          docker run --rm -v $(pwd):/src zricethezav/gitleaks:latest detect --source /src --report-format json --report-path /src/gitleaks.json || exit_code=$?
        continue-on-error: true

      - name: Display Gitleaks report
        run: |
          if [ -f gitleaks.json ]; then
            cat gitleaks.json
          else
            echo "No gitleaks report generated"
          fi
        continue-on-error: true

      - name: Upload Gitleaks report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks.json
        if: always()

  scan:
    runs-on: ubuntu-latest
    needs: precheck
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube (SAST)
        run: |
          docker run --rm -v $(pwd):/usr/src \
            -e SONAR_TOKEN=${{ secrets.SONAR_TOKEN }} \
            -e SONAR_HOST_URL=${{ secrets.SONAR_HOST_URL }} \
            -e SONAR_ORGANIZATION=${{ secrets.SONAR_ORGANIZATION }} \
            -e SONAR_PROJECT_KEY=${{ secrets.SONAR_PROJECT_KEY }} \
            -e SONAR_USER_HOME=/usr/src/.sonar \
            sonarsource/sonar-scanner-cli:latest \
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }} \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.login=${{ secrets.SONAR_TOKEN }} \
            -Dsonar.sources=src/main/java \
            -Dsonar.java.source=17 \
            -Dsonar.java.target=17 \
            -Dsonar.exclusions=**/test/**
        continue-on-error: true

      - name: Snyk (SCA)
        run: |
          docker run --rm -v $(pwd):/src \
            -e SNYK_TOKEN=${{ secrets.SNYK_TOKEN }} \
            node:18 sh -c "cd /src && npm install -g snyk && snyk auth \$SNYK_TOKEN && snyk test --json > snyk-report.json" || true
        continue-on-error: true

      - name: Upload Snyk report
        uses: actions/upload-artifact@v4
        with:
          name: snyk-report
          path: snyk-report.json
        if: always()

  build:
    runs-on: ubuntu-latest
    needs: scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ env.IMAGE_TAG }}, local-image:latest
          outputs: type=docker,dest=docker-image.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar

  image-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Trivy scan
        run: |
          docker run --rm -v $(pwd):/src aquasec/trivy:latest image --input /src/docker-image.tar --format json --output /src/trivy-report.json --severity HIGH,CRITICAL || SCAN_EXIT=$?
        continue-on-error: true

      - name: Check Trivy results
        run: |
          if [ -f trivy-report.json ]; then
            cat trivy-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-report.json || echo 0)
            echo "CRITICAL vulns: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "‚ùå CRITICAL vulnerabilities detected by Trivy. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report generated"
          fi

      - name: Upload Trivy report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-report.json
        if: always()

  push:
    runs-on: ubuntu-latest
    needs: image-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Load Docker image
        run: docker load < docker-image.tar

      - name: Tag image
        run: docker tag local-image:latest ${{ env.IMAGE_TAG }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push image
        run: docker push ${{ env.IMAGE_TAG }}

  deploy-to-staging:
    runs-on: ubuntu-latest
    needs: push
    if: false  # D√©sactiv√© pour test sans d√©ploiement
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          docker run --rm -v $(pwd):/workspace \
            -e KUBECONFIG_DATA=${{ secrets.KUBECONFIG_DATA }} \
            -e TARGET_NAMESPACE=${{ env.STAGING_NAMESPACE }} \
            -e IMAGE_TAG=${{ env.IMAGE_TAG }} \
            -e NODE_PORT=${{ env.NODE_PORT_STAGING }} \
            -e APP_PORT=${{ env.APP_PORT }} \
            bitnami/kubectl:latest sh -c "
              mkdir -p ~/.kube
              echo \$KUBECONFIG_DATA | base64 -d > ~/.kube/config
              CONTEXT=\$(kubectl config get-contexts -o name | head -n1)
              kubectl config use-context \$CONTEXT
              envsubst < /workspace/k8s/deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              kubectl rollout status deployment/myapp -n \$TARGET_NAMESPACE
            "

  security-scan:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: false  # D√©sactiv√© pour test sans d√©ploiement
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: OWASP ZAP scan
        run: |
          echo "üîç Testing target availability..."
          curl -s --head --connect-timeout 30 "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" || echo "Target might be starting..."
          
          echo "üì¶ Pulling ZAP image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          echo "üöÄ Starting ZAP scan..."
          docker run --rm \
            -v $(pwd):/zap/wrk/:rw \
            -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" \
            -m 10 \
            -g gen.conf \
            -r zap_report.html \
            -J zap_report.json \
            -w zap_report.md

      - name: Upload ZAP reports
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: zap_report.*
        if: always()

  promote-to-prod:
    runs-on: ubuntu-latest
    needs: security-scan
    if: false  # D√©sactiv√© pour test sans d√©ploiement
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Promote to production
        run: |
          docker run --rm -v $(pwd):/workspace \
            -e KUBECONFIG_DATA=${{ secrets.KUBECONFIG_DATA }} \
            -e TARGET_NAMESPACE=${{ env.PROD_NAMESPACE }} \
            -e IMAGE_TAG=${{ env.IMAGE_TAG }} \
            -e NODE_PORT=${{ env.NODE_PORT_PROD }} \
            -e APP_PORT=${{ env.APP_PORT }} \
            bitnami/kubectl:latest sh -c "
              mkdir -p ~/.kube
              echo \$KUBECONFIG_DATA | base64 -d > ~/.kube/config
              CONTEXT=\$(kubectl config get-contexts -o name | head -n1)
              kubectl config use-context \$CONTEXT
              envsubst < /workspace/k8s/deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              kubectl rollout status deployment/myapp -n \$TARGET_NAMESPACE
            "

      - name: Create service info artifact
        run: |
          echo "APP_URL=http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_PROD }}" > service_info.env

      - name: Upload service info
        uses: actions/upload-artifact@v4
        with:
          name: service-info
          path: service_info.env