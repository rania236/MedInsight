name: CI/CD Pipeline

# Test commit for pipeline trigger
# Ce workflow d√©finit un pipeline CI/CD complet pour l'application Java Spring Boot
# Il s'ex√©cute sur les push et PR vers main/master

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

# Variables d'environnement globales utilis√©es dans les jobs
env:
  IMAGE_TAG_PATIENT: ghcr.io/rania236/patient-service:${{ github.sha }}  # Tag pour patient-service
  IMAGE_TAG_DOCTOR: ghcr.io/rania236/doctor-service:${{ github.sha }}  # Tag pour doctor-service
  REGISTRY: ghcr.io  # Registre GitHub Container Registry
  STAGING_NAMESPACE: medinsight  # Namespace pour staging (vos microservices)
  PROD_NAMESPACE: medinsight  # Namespace pour production (m√™me namespace pour simplicit√©)
  APP_PORT_PATIENT: 8050  # Port pour patient-service
  APP_PORT_DOCTOR: 8080  # Port pour doctor-service
  NODE_PORT_STAGING_PATIENT: "30080"  # Port NodePort pour patient staging
  NODE_PORT_STAGING_DOCTOR: "30081"  # Port NodePort pour doctor staging
  NODE_PORT_PROD_PATIENT: "30082"  # Port NodePort pour patient prod
  NODE_PORT_PROD_DOCTOR: "30083"  # Port NodePort pour doctor prod
  MINIKUBE_IP: "172.31.29.183"  # IP du master kubeadm
  SONAR_USER_HOME: "${{ github.workspace }}/.sonar"  # Cache pour SonarQube
  GIT_DEPTH: 0  # R√©cup√©rer tout l'historique Git

jobs:
  # Job 1: Pr√©-v√©rification - D√©tection de secrets
  precheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # R√©cup√©rer tout l'historique pour Gitleaks

      - name: Gitleaks - secrets detection
        run: |
          docker run --rm -v $(pwd):/src zricethezav/gitleaks:latest detect --source /src --report-format json --report-path /src/gitleaks.json || exit_code=$?
        continue-on-error: true  # Ne pas √©chouer le pipeline si des secrets sont trouv√©s

      - name: Display Gitleaks report
        run: |
          if [ -f gitleaks.json ]; then
            cat gitleaks.json
          else
            echo "No gitleaks report generated"
          fi
        continue-on-error: true

      - name: Upload Gitleaks report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks.json
        if: always()  # Toujours uploader m√™me en cas d'√©chec

  # Job 2: Scan - Analyse de s√©curit√© et qualit√© du code
  scan:
    runs-on: ubuntu-latest
    needs: precheck  # D√©pend du job pr√©c√©dent
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube (SAST)
        run: |
          docker run --rm -v $(pwd):/usr/src \
            -e SONAR_TOKEN=${{ secrets.SONAR_TOKEN }} \
            -e SONAR_HOST_URL=${{ secrets.SONAR_HOST_URL }} \
            -e SONAR_ORGANIZATION=${{ secrets.SONAR_ORGANIZATION }} \
            -e SONAR_PROJECT_KEY=${{ secrets.SONAR_PROJECT_KEY }} \
            -e SONAR_USER_HOME=/usr/src/.sonar \
            sonarsource/sonar-scanner-cli:latest \
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }} \
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
            -Dsonar.login=${{ secrets.SONAR_TOKEN }} \
            -Dsonar.sources=src/main/java \
            -Dsonar.java.source=17 \
            -Dsonar.java.target=17 \
            -Dsonar.exclusions=**/test/**
        continue-on-error: true  # Permettre la continuation m√™me si SonarQube √©choue

      - name: Snyk (SCA)
        run: |
          docker run --rm -v $(pwd):/src \
            -e SNYK_TOKEN=${{ secrets.SNYK_TOKEN }} \
            node:18 sh -c "cd /src && npm install -g snyk && snyk auth \$SNYK_TOKEN && snyk test --json > snyk-report.json" || true
        continue-on-error: true

      - name: Upload Snyk report
        uses: actions/upload-artifact@v4
        with:
          name: snyk-report
          path: snyk-report.json
        if: always()

  # Job 3: Build - Construction de l'image Docker
  build:
    runs-on: ubuntu-latest
    needs: scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3  # Pr√©parer Docker pour le build

      - name: Build patient-service Docker image
        uses: docker/build-push-action@v5
        with:
          context: services/patient-service/patient-service  # Contexte pour patient-service
          tags: ${{ env.IMAGE_TAG_PATIENT }}, patient-local:latest  # Tags pour patient-service
          outputs: type=docker,dest=patient-docker-image.tar  # Sauvegarder l'image patient

      - name: Build doctor-service Docker image
        uses: docker/build-push-action@v5
        with:
          context: services/doctor-service  # Contexte pour doctor-service
          tags: ${{ env.IMAGE_TAG_DOCTOR }}, doctor-local:latest  # Tags pour doctor-service
          outputs: type=docker,dest=doctor-docker-image.tar  # Sauvegarder l'image doctor

      - name: Upload patient Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: patient-docker-image
          path: patient-docker-image.tar  # Artifact pour patient

      - name: Upload doctor Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: doctor-docker-image
          path: doctor-docker-image.tar  # Artifact pour doctor

  # Job 4: Image-scan - Scan de vuln√©rabilit√©s de l'image Docker
  image-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download patient Docker image
        uses: actions/download-artifact@v4
        with:
          name: patient-docker-image
          path: .

      - name: Download doctor Docker image
        uses: actions/download-artifact@v4
        with:
          name: doctor-docker-image
          path: .

      - name: Load patient Docker image
        run: docker load < patient-docker-image.tar

      - name: Load doctor Docker image
        run: docker load < doctor-docker-image.tar

      - name: Trivy scan patient-service
        run: |
          docker run --rm aquasec/trivy:latest image patient-local:latest --format json --output trivy-patient-report.json --severity HIGH,CRITICAL || SCAN_EXIT=$?
        continue-on-error: true

      - name: Trivy scan doctor-service
        run: |
          docker run --rm aquasec/trivy:latest image doctor-local:latest --format json --output trivy-doctor-report.json --severity HIGH,CRITICAL || SCAN_EXIT=$?
        continue-on-error: true

      - name: Check Trivy results for patient-service
        run: |
          if [ -f trivy-patient-report.json ]; then
            cat trivy-patient-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-patient-report.json || echo 0)
            echo "CRITICAL vulns in patient-service: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "‚ùå CRITICAL vulnerabilities detected in patient-service. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report for patient-service"
          fi
        continue-on-error: true

      - name: Check Trivy results for doctor-service
        run: |
          if [ -f trivy-doctor-report.json ]; then
            cat trivy-doctor-report.json
            CRITICAL=$(jq '[.[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-doctor-report.json || echo 0)
            echo "CRITICAL vulns in doctor-service: $CRITICAL"
            if [ "$CRITICAL" -gt 0 ]; then
              echo "‚ùå CRITICAL vulnerabilities detected in doctor-service. Failing pipeline."
              exit 1
            fi
          else
            echo "No trivy report for doctor-service"
          fi
        continue-on-error: true

      - name: Upload Trivy patient report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-patient-report
          path: trivy-patient-report.json
        if: always()

      - name: Upload Trivy doctor report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-doctor-report
          path: trivy-doctor-report.json
        if: always()

  # Job 5: Push - Push de l'image vers le registre
  push:
    runs-on: ubuntu-latest
    needs: image-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'  # Seulement sur main/master
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download patient Docker image
        uses: actions/download-artifact@v4
        with:
          name: patient-docker-image
          path: .

      - name: Download doctor Docker image
        uses: actions/download-artifact@v4
        with:
          name: doctor-docker-image
          path: .

      - name: Load patient Docker image
        run: docker load < patient-docker-image.tar

      - name: Load doctor Docker image
        run: docker load < doctor-docker-image.tar

      - name: Tag patient image
        run: docker tag patient-local:latest ${{ env.IMAGE_TAG_PATIENT }}

      - name: Tag doctor image
        run: docker tag doctor-local:latest ${{ env.IMAGE_TAG_DOCTOR }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push patient image
        run: docker push ${{ env.IMAGE_TAG_PATIENT }}

      - name: Push doctor image
        run: docker push ${{ env.IMAGE_TAG_DOCTOR }}

  # Job 6: Deploy to staging - D√©ploiement en environnement de staging
  deploy-to-staging:
    runs-on: ubuntu-latest
    needs: push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'  # Activ√© pour test en staging
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          docker run --rm -v $(pwd):/workspace \
            -e KUBECONFIG_DATA=${{ secrets.KUBECONFIG_DATA }} \
            -e TARGET_NAMESPACE=${{ env.STAGING_NAMESPACE }} \
            -e NAMESPACE=${{ env.STAGING_NAMESPACE }} \
            -e IMAGE_TAG_PATIENT=${{ env.IMAGE_TAG_PATIENT }} \
            -e IMAGE_TAG_DOCTOR=${{ env.IMAGE_TAG_DOCTOR }} \
            -e NODE_PORT_PATIENT=${{ env.NODE_PORT_STAGING_PATIENT }} \
            -e NODE_PORT_DOCTOR=${{ env.NODE_PORT_STAGING_DOCTOR }} \
            -e APP_PORT_PATIENT=${{ env.APP_PORT_PATIENT }} \
            -e APP_PORT_DOCTOR=${{ env.APP_PORT_DOCTOR }} \
            bitnami/kubectl:latest sh -c "
              mkdir -p ~/.kube
              echo \$KUBECONFIG_DATA | base64 -d > ~/.kube/config
              CONTEXT=\$(kubectl config get-contexts -o name | head -n1)
              kubectl config use-context \$CONTEXT
              envsubst < /workspace/k8s/patient-deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/patient-service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/doctor-deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/doctor-service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              kubectl rollout status deployment/patient-service -n \$TARGET_NAMESPACE
              kubectl rollout status deployment/doctor-service -n \$TARGET_NAMESPACE
            "

  # Job 7: Security-scan - Scan de s√©curit√© dynamique avec OWASP ZAP
  security-scan:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: false  # D√©sactiv√© pour test sans d√©ploiement
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: OWASP ZAP scan
        run: |
          echo "üîç Testing target availability..."
          curl -s --head --connect-timeout 30 "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" || echo "Target might be starting..."
          
          echo "üì¶ Pulling ZAP image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          echo "üöÄ Starting ZAP scan..."
          docker run --rm \
            -v $(pwd):/zap/wrk/:rw \
            -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_STAGING }}" \
            -m 10 \
            -g gen.conf \
            -r zap_report.html \
            -J zap_report.json \
            -w zap_report.md

      - name: Upload ZAP reports
        uses: actions/upload-artifact@v4
        with:
          name: zap-reports
          path: zap_report.*
        if: always()

  # Job 8: Promote to prod - Promotion en production
  promote-to-prod:
    runs-on: ubuntu-latest
    needs: security-scan
    if: false  # D√©sactiv√© pour test sans d√©ploiement
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Promote to production
        run: |
          docker run --rm -v $(pwd):/workspace \
            -e KUBECONFIG_DATA=${{ secrets.KUBECONFIG_DATA }} \
            -e TARGET_NAMESPACE=${{ env.PROD_NAMESPACE }} \
            -e NAMESPACE=${{ env.PROD_NAMESPACE }} \
            -e IMAGE_TAG_PATIENT=${{ env.IMAGE_TAG_PATIENT }} \
            -e IMAGE_TAG_DOCTOR=${{ env.IMAGE_TAG_DOCTOR }} \
            -e NODE_PORT_PATIENT=${{ env.NODE_PORT_PROD_PATIENT }} \
            -e NODE_PORT_DOCTOR=${{ env.NODE_PORT_PROD_DOCTOR }} \
            -e APP_PORT_PATIENT=${{ env.APP_PORT_PATIENT }} \
            -e APP_PORT_DOCTOR=${{ env.APP_PORT_DOCTOR }} \
            bitnami/kubectl:latest sh -c "
              mkdir -p ~/.kube
              echo \$KUBECONFIG_DATA | base64 -d > ~/.kube/config
              CONTEXT=\$(kubectl config get-contexts -o name | head -n1)
              kubectl config use-context \$CONTEXT
              envsubst < /workspace/k8s/patient-deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/patient-service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/doctor-deployment.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              envsubst < /workspace/k8s/doctor-service.yaml | kubectl apply -n \$TARGET_NAMESPACE -f - --validate=false
              kubectl rollout status deployment/patient-service -n \$TARGET_NAMESPACE
              kubectl rollout status deployment/doctor-service -n \$TARGET_NAMESPACE
            "

      - name: Create service info artifact
        run: |
          echo "APP_URL=http://${{ env.MINIKUBE_IP }}:${{ env.NODE_PORT_PROD }}" > service_info.env

      - name: Upload service info
        uses: actions/upload-artifact@v4
        with:
          name: service-info
          path: service_info.env